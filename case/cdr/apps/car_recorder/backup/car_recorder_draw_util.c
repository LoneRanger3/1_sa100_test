/*
 * car_recorder_draw_util.c - draw rectangle and line functions.
 *
 * Copyright (C) 2016-2018, LomboTech Co.Ltd.
 * Author: lomboswer <lomboswer@lombotech.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <rtthread.h>
#include "app_manage.h"
#include "car_recorder_draw_util.h"
#include "car_recorder_draw.h"

#define CAR_REC_ADAS_COLOR_RED		(0xff0000)
#define CAR_REC_ADAS_COLOR_GREEN	(0x00ff00)
#define CAR_REC_ADAS_COLOR_YELLOW	(0xffff00)
#define CAR_REC_ADAS_COLOR_BLUE		(0x0000ff)
#define CAR_REC_BSD_COLOR_ORANGE	(0xfe571e)

#define CAR_REC_ADAS_OPA_TRANSP		0
#define CAR_REC_ADAS_OPA_10		(0x19000000)
#define CAR_REC_ADAS_OPA_20		(0x33000000)
#define CAR_REC_ADAS_OPA_30		(0x4C000000)
#define CAR_REC_ADAS_OPA_40		(0x66000000)
#define CAR_REC_ADAS_OPA_50		(0x7f000000)
#define CAR_REC_ADAS_OPA_60		(0x99000000)
#define CAR_REC_ADAS_OPA_70		(0xB2000000)
#define CAR_REC_ADAS_OPA_80		(0xCC000000)
#define CAR_REC_ADAS_OPA_90		(0xE5000000)
#define CAR_REC_ADAS_OPA_COVER		(0xff000000)

#define CAR_REC_FONT_HEIGHT		(20)

typedef struct tag_adas_font_t {
	char	ch;
	char	*font_p;
	char	width;
} adas_font_t;

static int car_recorder_adas_round(float a);
static void car_recorder_adas_line_with_dda(unsigned char *buff,
	int x_start, int y_start, int x_end, int y_end, unsigned char dir);
static int car_recorder_adas_draw_ch(unsigned char *buff, int idx,
					int x, int y, int w, int h);

static char number_0[] = {
	/*Unicode: U+0030 (0) , Width: 9 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x06, 0x7e, 0xdc, 0xf8, 0xdc, 0x7e, 0x04, 0x00,  //..+@@@+..
	0x00, 0xac, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaa, 0x00,  //.%@@@@@%.
	0x46, 0xff, 0xf0, 0x46, 0x06, 0x46, 0xf0, 0xff, 0x44,  //+@@+.+@@+
	0xa2, 0xff, 0x76, 0x00, 0x00, 0x00, 0x76, 0xff, 0xa0,  //%@+...+@%
	0xd6, 0xff, 0x2c, 0x00, 0x00, 0x00, 0x2c, 0xff, 0xd6,  //@@.....@@
	0xf2, 0xff, 0x0a, 0x00, 0x00, 0x00, 0x0a, 0xff, 0xf0,  //@@.....@@
	0xfc, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfa,  //@@.....@@
	0xf2, 0xff, 0x0a, 0x00, 0x00, 0x00, 0x0a, 0xff, 0xf0,  //@@.....@@
	0xd6, 0xff, 0x2c, 0x00, 0x00, 0x00, 0x2c, 0xff, 0xd6,  //@@.....@@
	0xa2, 0xff, 0x76, 0x00, 0x00, 0x00, 0x76, 0xff, 0xa2,  //%@+...+@%
	0x48, 0xff, 0xf0, 0x44, 0x06, 0x44, 0xf0, 0xff, 0x46,  //+@@+.+@@+
	0x00, 0xae, 0xff, 0xff, 0xff, 0xff, 0xff, 0xac, 0x00,  //.%@@@@@%.
	0x00, 0x06, 0x80, 0xde, 0xf8, 0xde, 0x80, 0x06, 0x00,  //..+@@@+..
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
};
static char number_1[] = {
	/*Unicode: U+0031 (1) , Width: 8 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x26, 0x76, 0xc6, 0xfc, 0xff, 0x00, 0x00, 0x00,  //.+@@@...
	0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,  //@@@@@...
	0xd4, 0x7e, 0x2a, 0xff, 0xff, 0x00, 0x00, 0x00,  //@+.@@...
	0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,  //...@@...
	0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,  //...@@...
	0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,  //...@@...
	0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,  //...@@...
	0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,  //...@@...
	0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,  //...@@...
	0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,  //...@@...
	0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,  //...@@...
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  //@@@@@@@@
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  //@@@@@@@@
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
};
static char number_2[] = {
	/*Unicode: U+0032 (2) , Width: 9 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x36, 0x98, 0xdc, 0xf8, 0xe0, 0xae, 0x34, 0x00, 0x00,  //.%@@@%...
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x50, 0x00,  //@@@@@@@+.
	0xc4, 0x5e, 0x1c, 0x06, 0x2e, 0xc4, 0xff, 0xd6, 0x00,  //@+...@@@.
	0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xff, 0xf6, 0x00,  //......@@.
	0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0xff, 0xd2, 0x00,  //......@@.
	0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0xff, 0x7a, 0x00,  //.....%@+.
	0x00, 0x00, 0x00, 0x00, 0x58, 0xfc, 0xd8, 0x08, 0x00,  //....+@@..
	0x00, 0x00, 0x00, 0x58, 0xfa, 0xf2, 0x2c, 0x00, 0x00,  //...+@@...
	0x00, 0x00, 0x64, 0xfc, 0xfa, 0x4e, 0x00, 0x00, 0x00,  //..+@@+...
	0x00, 0x6e, 0xff, 0xfc, 0x60, 0x00, 0x00, 0x00, 0x00,  //.+@@+....
	0x7a, 0xff, 0xfc, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00,  //+@@+.....
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x12,  //@@@@@@@@.
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x12,  //@@@@@@@@.
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
};
static char number_3[] = {
	/*Unicode: U+0033 (3) , Width: 9 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x30, 0x8c, 0xd0, 0xf4, 0xf0, 0xd6, 0x9a, 0x2c, 0x00,  //.%@@@@%..
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x56,  //@@@@@@@@+
	0xc8, 0x6a, 0x26, 0x04, 0x0c, 0x32, 0xa8, 0xff, 0xde,  //@+....%@@
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0xff, 0xee,  //.......@@
	0x00, 0x00, 0x00, 0x00, 0x0a, 0x2c, 0xa2, 0xff, 0x92,  //......%@%
	0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xdc, 0x74, 0x02,  //..@@@@@+.
	0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xf2, 0x8e, 0x04,  //..@@@@@%.
	0x00, 0x00, 0x00, 0x00, 0x10, 0x44, 0xcc, 0xff, 0x8c,  //.....+@@%
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0xff, 0xe6,  //.......@@
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0xff, 0xf2,  //.......@@
	0xb8, 0x4e, 0x14, 0x02, 0x14, 0x4a, 0xd2, 0xff, 0xb6,  //%+...+@@%
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0x28,  //@@@@@@@@.
	0x38, 0x9e, 0xde, 0xfa, 0xf2, 0xd0, 0x8a, 0x18, 0x00,  //.%@@@@%..
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
};
static char number_4[] = {
	/*Unicode: U+0034 (4) , Width: 10 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	//..........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	//..........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	//..........
	0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xff, 0xff, 0x00, 0x00,	//.....%@@..
	0x00, 0x00, 0x00, 0x00, 0x5a, 0xf8, 0xff, 0xff, 0x00, 0x00,	//....+@@@..
	0x00, 0x00, 0x00, 0x1a, 0xee, 0x7a, 0xff, 0xff, 0x00, 0x00,	//....@+@@..
	0x00, 0x00, 0x00, 0xb6, 0xcc, 0x02, 0xff, 0xff, 0x00, 0x00,	//...%@.@@..
	0x00, 0x00, 0x66, 0xf8, 0x2c, 0x00, 0xff, 0xff, 0x00, 0x00,	//..+@..@@..
	0x00, 0x22, 0xf2, 0x7a, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,	//..@+..@@..
	0x00, 0xc2, 0xca, 0x02, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,	//.@@...@@..
	0x74, 0xf8, 0x2a, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,	//+@....@@..
	0xf6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,	//@@@@@@@@@@
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,	//@@@@@@@@@@
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,	//......@@..
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,	//......@@..
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,	//......@@..
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	//..........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	//..........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	//..........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	//..........
};
static char number_5[] = {
	/*Unicode: U+0035 (5) , Width: 8 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,  //.@@@@@@.
	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,  //.@@@@@@.
	0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,  //.@@.....
	0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,  //.@@.....
	0x00, 0xff, 0xff, 0xd4, 0xf6, 0xc4, 0x3c, 0x00,  //.@@@@@..
	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0x2e,  //.@@@@@@.
	0x00, 0xa2, 0x26, 0x08, 0x3e, 0xd8, 0xff, 0xaa,  //.%...@@%
	0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0xff, 0xe8,  //......@@
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xff, 0xfa,  //......@@
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0xff, 0xe4,  //......@@
	0xb2, 0x40, 0x0a, 0x0e, 0x4c, 0xe0, 0xff, 0x9c,  //%...+@@%
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe4, 0x1a,  //@@@@@@@.
	0x40, 0xac, 0xea, 0xf8, 0xde, 0x96, 0x18, 0x00,  //.%@@@%..
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
};
static char number_6[] = {
	/*Unicode: U+0036 (6) , Width: 9 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x30, 0xac, 0xea, 0xf6, 0xc2, 0x4c, 0x00,  //...%@@@+.
	0x00, 0x4c, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,  //.+@@@@@@.
	0x16, 0xee, 0xff, 0xb6, 0x2a, 0x06, 0x32, 0xb4, 0x00,  //.@@%...%.
	0x80, 0xff, 0xd8, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,  //+@@......
	0xc8, 0xff, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //@@+......
	0xee, 0xff, 0x34, 0x90, 0xee, 0xf2, 0xba, 0x3a, 0x00,  //@@.%@@%..
	0xfa, 0xff, 0xa8, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x3a,  //@@%@@@@@.
	0xf2, 0xff, 0xb8, 0x2a, 0x06, 0x2a, 0xba, 0xff, 0xbe,  //@@%...%@%
	0xd6, 0xff, 0x1a, 0x00, 0x00, 0x00, 0x1a, 0xff, 0xf4,  //@@.....@@
	0xa0, 0xff, 0x1a, 0x00, 0x00, 0x00, 0x1a, 0xff, 0xf2,  //%@.....@@
	0x42, 0xff, 0xba, 0x28, 0x06, 0x28, 0xba, 0xff, 0xb8,  //+@%...%@%
	0x00, 0xa4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf2, 0x30,  //.%@@@@@@.
	0x00, 0x02, 0x76, 0xd8, 0xf8, 0xec, 0xaa, 0x2a, 0x00,  //..+@@@%..
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
};
static char number_7[] = {
	/*Unicode: U+0037 (7) , Width: 8 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,  //@@@@@@@@
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc2,  //@@@@@@@@
	0x00, 0x00, 0x00, 0x00, 0x00, 0xa8, 0xff, 0x70,  //.....%@+
	0x00, 0x00, 0x00, 0x00, 0x06, 0xf0, 0xff, 0x20,  //.....@@.
	0x00, 0x00, 0x00, 0x00, 0x4a, 0xff, 0xd0, 0x00,  //....+@@.
	0x00, 0x00, 0x00, 0x00, 0x9c, 0xff, 0x7e, 0x00,  //....%@+.
	0x00, 0x00, 0x00, 0x02, 0xea, 0xff, 0x2e, 0x00,  //....@@..
	0x00, 0x00, 0x00, 0x3e, 0xff, 0xdc, 0x00, 0x00,  //....@@..
	0x00, 0x00, 0x00, 0x90, 0xff, 0x8c, 0x00, 0x00,  //...%@%..
	0x00, 0x00, 0x00, 0xe0, 0xff, 0x3c, 0x00, 0x00,  //...@@...
	0x00, 0x00, 0x34, 0xff, 0xe8, 0x00, 0x00, 0x00,  //...@@...
	0x00, 0x00, 0x84, 0xff, 0x9a, 0x00, 0x00, 0x00,  //..%@%...
	0x00, 0x00, 0xd6, 0xff, 0x4a, 0x00, 0x00, 0x00,  //..@@+...
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //........
};
static char number_8[] = {
	/*Unicode: U+0038 (8) , Width: 9 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x42, 0xb2, 0xe0, 0xf6, 0xe0, 0xb2, 0x42, 0x00,  //.+%@@@%+.
	0x6a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6a,  //+@@@@@@@+
	0xe4, 0xff, 0x96, 0x1e, 0x04, 0x1e, 0x98, 0xff, 0xe4,  //@@%...%@@
	0xee, 0xff, 0x0e, 0x00, 0x00, 0x00, 0x10, 0xff, 0xec,  //@@.....@@
	0x92, 0xff, 0x94, 0x1c, 0x04, 0x1e, 0x96, 0xff, 0x92,  //%@%...%@%
	0x02, 0x76, 0xe0, 0xff, 0xff, 0xff, 0xe0, 0x76, 0x02,  //.+@@@@@+.
	0x02, 0x8c, 0xf2, 0xff, 0xff, 0xff, 0xf2, 0x8c, 0x02,  //.%@@@@@%.
	0x86, 0xff, 0xb8, 0x28, 0x06, 0x2a, 0xba, 0xff, 0x86,  //%@%...%@%
	0xe4, 0xff, 0x1a, 0x00, 0x00, 0x00, 0x1a, 0xff, 0xe4,  //@@.....@@
	0xf6, 0xff, 0x1a, 0x00, 0x00, 0x00, 0x1a, 0xff, 0xf6,  //@@.....@@
	0xc8, 0xff, 0xb8, 0x28, 0x06, 0x28, 0xba, 0xff, 0xc6,  //@@%...%@@
	0x46, 0xfa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x44,  //+@@@@@@@+
	0x00, 0x2e, 0xaa, 0xde, 0xf8, 0xea, 0xb2, 0x38, 0x00,  //..%@@@%..
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
};
static char number_9[] = {
	/*Unicode: U+0039 (9) , Width: 9 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x2a, 0xaa, 0xea, 0xf8, 0xd6, 0x72, 0x02, 0x00,  //..%@@@+..
	0x30, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9c, 0x00,  //.@@@@@@%.
	0xb8, 0xff, 0xbc, 0x2a, 0x06, 0x2a, 0xbc, 0xff, 0x3e,  //%@%...%@.
	0xf2, 0xff, 0x1a, 0x00, 0x00, 0x00, 0x1a, 0xff, 0x9c,  //@@.....@%
	0xf4, 0xff, 0x1a, 0x00, 0x00, 0x00, 0x1a, 0xff, 0xd4,  //@@.....@@
	0xc0, 0xff, 0xba, 0x28, 0x06, 0x28, 0xb8, 0xff, 0xf0,  //%@%...%@@
	0x40, 0xfa, 0xff, 0xff, 0xff, 0xff, 0xaa, 0xff, 0xfa,  //.@@@@@%@@
	0x00, 0x3e, 0xbc, 0xf2, 0xee, 0x90, 0x34, 0xff, 0xee,  //..%@@%.@@
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0xff, 0xc6,  //......+@@
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xd6, 0xff, 0x7e,  //......@@+
	0x00, 0xb2, 0x30, 0x04, 0x28, 0xb4, 0xff, 0xee, 0x16,  //.%...%@@.
	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x4c, 0x00,  //.@@@@@@+.
	0x00, 0x4c, 0xc2, 0xf6, 0xea, 0xac, 0x30, 0x00, 0x00,  //.+@@@%...
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //.........
};
static char unit_m[] = {
	/*Unicode: U+006d (m) , Width: 14 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //..............
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //..............
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //..............
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //..............
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //..............
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //..............
	0xff, 0xff, 0x0a, 0x9e, 0xf0, 0xe6, 0x6e, 0x00, 0x10, 0xa2, 0xee, 0xea, 0x84, 0x00,  //@@.%@@+..%@@%.
	0xff, 0xff, 0xac, 0xff, 0xff, 0xff, 0xff, 0x4c, 0xc8, 0xff, 0xff, 0xff, 0xff, 0x5c,  //@@%@@@@+@@@@@+
	0xff, 0xff, 0xce, 0x2c, 0x0c, 0x94, 0xff, 0xee, 0xce, 0x2c, 0x0c, 0x94, 0xff, 0xc2,  //@@@..%@@@..%@@
	0xff, 0xff, 0x36, 0x00, 0x00, 0x18, 0xff, 0xff, 0x36, 0x00, 0x00, 0x18, 0xff, 0xe8,  //@@....@@....@@
	0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0xff, 0xfc,  //@@....@@....@@
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,  //@@....@@....@@
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,  //@@....@@....@@
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,  //@@....@@....@@
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,  //@@....@@....@@
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,  //@@....@@....@@
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //..............
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //..............
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //..............
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //..............
};

static adas_font_t adas_font[] = {
	{'0', number_0, 9},
	{'1', number_1, 8},
	{'2', number_2, 9},
	{'3', number_3, 9},
	{'4', number_4, 10},
	{'5', number_5, 8},
	{'6', number_6, 9},
	{'7', number_7, 8},
	{'8', number_8, 9},
	{'9', number_9, 9},
	{'m', unit_m, 14},
};
static int g_act_width;

int car_recorder_adas_draw_rect(unsigned char *p_buff, int len, char b_color)
{
	int i;
	int *p_test_data = (int *)p_buff;

	if (p_buff == NULL)
		return -1;

	if (b_color == 0) {
		for (i = 0; i < len / 4; i++)
			p_test_data[i] = CAR_REC_ADAS_OPA_40 | CAR_REC_ADAS_COLOR_RED;
	} else if (b_color == 1) {
		for (i = 0; i < len / 4; i++)
			p_test_data[i] = CAR_REC_ADAS_OPA_40 | CAR_REC_ADAS_COLOR_GREEN;
	} else {
		for (i = 0; i < len / 4; i++)
			p_test_data[i] = CAR_REC_ADAS_OPA_COVER |
					CAR_REC_ADAS_COLOR_YELLOW;
	}

	return 0;
}

int car_recorder_adas_draw_line(unsigned char *buff,
				line_point start,
				line_point end,
				unsigned char dir)
{
	if (dir == 0)
		car_recorder_adas_line_with_dda(buff, start.x,
				start.y, end.x, end.y, dir);
	else
		car_recorder_adas_line_with_dda(buff, end.x,
				start.y, start.x, end.y, dir);

	return 0;
}

static int car_recorder_adas_round(float a)
{
	return (int)(a + 0.5);
}

/* DDA */
static void car_recorder_adas_line_with_dda(unsigned char *buff, int x_start,
			int y_start, int x_end, int y_end, unsigned char dir)
{
	int dx = x_end - x_start, dy = y_end - y_start, steps, k;
	float x_steps, y_steps, x = 0, y = 0;
	int *p_test_data;
	int i = 0, px;

	p_test_data = (int *)buff;

	if (abs(dx) > abs(dy))
		steps = abs(dx);
	else
		steps = abs(dy);


	x_steps = (float)dx / (float)steps;
	y_steps = (float)dy / (float)steps;

	if (dir == 0) {
		x = 0;
		p_test_data[0] = CAR_REC_ADAS_OPA_COVER | CAR_REC_ADAS_COLOR_YELLOW;
	} else {
		x = abs(dx);
		p_test_data[dx] = CAR_REC_ADAS_OPA_COVER | CAR_REC_ADAS_COLOR_YELLOW;
	}

	for (k = 0; k < steps; k++) {
		x += x_steps;
		y += y_steps;

		px = car_recorder_adas_round(y) * dx + car_recorder_adas_round(x);
		p_test_data[px] = CAR_REC_ADAS_OPA_COVER | CAR_REC_ADAS_COLOR_YELLOW;
		for (i = 0; i < 3; i++) {
			if (car_recorder_adas_round(x + i) < abs(dx)) {
				px = car_recorder_adas_round(y) * dx +
					car_recorder_adas_round(x + i);
				p_test_data[px] = CAR_REC_ADAS_OPA_COVER |
						CAR_REC_ADAS_COLOR_YELLOW;
			}

			if (car_recorder_adas_round(x - i) >= 0) {
				px = car_recorder_adas_round(y) * dx +
					car_recorder_adas_round(x - i);
				p_test_data[px] = CAR_REC_ADAS_OPA_COVER |
						CAR_REC_ADAS_COLOR_YELLOW;
			}
		}
	}
}

int car_recorder_adas_draw_str(unsigned char *p_buff,
					line_point start,
					line_point end,
					char *p_str)
{
	int len = 0;
	int i, j;
	int start_x;
	int start_y;
	int w;
	int h;
	int width_total = 0;

	if ((NULL == p_buff) || (NULL == p_str))
		return -1;

	len = strlen(p_str);
	if (len == 0)
		return -2;

	for (i = 0; i < len; i++) {
		for (j = 0; j < sizeof(adas_font)/sizeof(adas_font_t); j++) {
			if (adas_font[j].ch == p_str[i]) {
				width_total += adas_font[j].width + 2;
				break;
			}
		}

		if (j >= sizeof(adas_font)/sizeof(adas_font_t))
			continue;
	}

	start_x = (abs(end.x - start.x) - CAR_REC_FONT_HEIGHT) / 2;
	start_y = (abs(end.y - start.y) - width_total) / 2;
	w = abs(end.x - start.x);
	h = abs(end.y - start.y);
	for (i = 0; i < len; i++) {
		for (j = 0; j < sizeof(adas_font)/sizeof(adas_font_t); j++) {
			if (adas_font[j].ch == p_str[i]) {
				car_recorder_adas_draw_ch(p_buff, j,
					start_x, start_y, w, h);
				start_y += adas_font[j].width + 2;
				break;
			}
		}

		if (j >= sizeof(adas_font)/sizeof(adas_font_t))
			continue;
	}

	return 0;
}

static int car_recorder_adas_draw_ch(unsigned char *buff, int idx,
					int x, int y, int w, int h)
{
	int i;
	int j;
	int *color_data;
	uint8_t alpha;

	if (NULL == buff)
		return -1;

	color_data = (int *)buff;
	for (j = CAR_REC_FONT_HEIGHT - 1; j >= 0; j--) {
		for (i = 0; i < adas_font[idx].width; i++) {
			alpha = adas_font[idx].font_p[j * adas_font[idx].width + i];
			if (alpha != 0x00) {
				color_data[(i + y) * w + CAR_REC_FONT_HEIGHT - j + x] =
					alpha << 24 | CAR_REC_ADAS_COLOR_YELLOW;
			}
		}
	}

	return 0;
}

/**
 * get polygon miny function of the canvas
 * @param points edge points of the polygon
 * @param size edge count of the polygon
 */
int16_t adas_draw_get_polygon_miny(line_point *points, uint8_t size)
{
	int16_t	min = points[0].y;
	uint8_t i;

	for (i = 0; i < size; i++) {
		if (min > points[i].y)
			min = points[i].y;
	}

	return min;
}

/**
 * get polygon maxy function of the canvas
 * @param points edge points of the polygon
 * @param size edge count of the polygon
 */
int16_t adas_draw_get_polygon_maxy(line_point *points, uint8_t size)
{
	int16_t	max = points[0].y;
	uint8_t i;

	for (i = 0; i < size; i++) {
		if (max < points[i].y)
			max = points[i].y;
	}

	return max;
}
/**
 * get polygon miny function of the canvas
 * @param points edge points of the polygon
 * @param size edge count of the polygon
 */
int32_t get_polygon_minx(line_point *points, uint8_t size)
{
	int32_t	min = points[0].x;
	uint8_t i;

	for (i = 0; i < size; i++) {
		if (min > points[i].x)
			min = points[i].x;
	}

	return min;
}

/**
 * get polygon miny function of the canvas
 * @param points edge points of the polygon
 * @param size edge count of the polygon
 */
int32_t get_polygon_maxx(line_point *points, uint8_t size)
{
	int32_t	max = points[0].x;
	uint8_t i;

	for (i = 0; i < size; i++) {
		if (max < points[i].x)
			max = points[i].x;
	}

	return max;
}

/**
 * swap value function of the canvas
 * @param int array.
 * @param i array index.
 * @param j array index.
 */
void adas_draw_swap(int *a, int i, int j)
{
	int temp = a[i];

	a[i] = a[j];
	a[j] = temp;
}

void adas_draw_msort(int *a, int begin, int end)
{
	int i, j;

	for (i = begin; i < end - 1; i++) {
		for (j = begin; j < end - 1 - i; j++) {
			if (a[j] > a[j + 1])
				adas_draw_swap(a, j, j + 1);
		}
	}
}

/**
 * Set the color of a pixel on the canvas
 * @param canvas
 * @param x x coordinate of the point to set
 * @param y x coordinate of the point to set
 * @param c color of the point
 */
void adas_draw_set_px(uint8_t *buff, int x, int y, int dx, uint32_t color)
{
	int act_x;

	if (x >= ADAS_BKL_LINE_WIDTH_MAX || y >= ADAS_BKL_LINE_HEIGHT_MAX) {
		APP_LOG_D("out of range x[%d] y[%d]!\n", x, y);
		return;
	}
	if (x >= g_act_width)
		act_x = g_act_width - 1;
	else
		act_x = x;

	/*uint32_t px = dx * y * sizeof(uint32_t) + x * sizeof(uint32_t);*/
	uint32_t px = g_act_width * y * sizeof(uint32_t) + act_x * sizeof(uint32_t);

	if (px < ADAS_BKL_LINE_WIDTH_MAX * ADAS_BKL_LINE_HEIGHT_MAX * 4 - 4)
		memcpy(&buff[px], &color, sizeof(uint32_t));
}

/**
 * Draw line function of the canvas
 * @param canvas pointer to a canvas object
 * @param point1 start point of the line
 * @param point2 end point of the line
 * @param color color of the line
 */
void adas_draw_line(uint8_t *buff, line_point point1,
		line_point point2 , int w, uint32_t color)
{
	int x0, y0, x1, y1;
	int width;

	x0 = point1.x;
	y0 = point1.y;
	x1 = point2.x;
	y1 = point2.y;

	width = w;

	APP_LOG_D("x0 = %d, y0 = %d, x1 = %d, y1 = %d width = %d\n",
		x0, y0, x1, y1, width);

	int dx = abs(x1-x0), sx = x0 < x1 ? 1 : -1;
	int dy = abs(y1-y0), sy = y0 < y1 ? 1 : -1;
	int err = (dx > dy ? dx : -dy)/2, e2;

	for (;;) {
		if (dx == 0)
			adas_draw_set_px(buff, x0, y0, width, color);
		else
			adas_draw_set_px(buff, x0, y0, dx, color);

		if (x0 == x1 && y0 == y1)
			break;
		e2 = err;
		if (e2 > -dx) {
			err -= dy;
			x0 += sx;
		}
		if (e2 < dy) {
			err += dx;
			y0 += sy;
		}
	}
}


/**
 * Draw polygon function of the canvas
 * @param canvas pointer to a canvas object
 * @param points edge points of the polygon
 * @param size edge count of the polygon
 */
void adas_draw_polygon(uint8_t *buff, line_point *points,
			uint8_t size, int w, uint32_t color)
{
	uint8_t i;

	for (i = 0; i < (size - 1); i++)
		adas_draw_line(buff, points[i], points[i + 1], w, color);

	adas_draw_line(buff, points[size - 1], points[0], w, color);
}

/**
 * Scanfill polygon function of the canvas
 * @param canvas pointer to a canvas object
 * @param points edge points of the polygon
 * @param size edge count of the polygon
 */
void adas_draw_scanfill_polygon(uint8_t *buff, line_point *points,
					uint8_t size, int w, uint32_t color)
{
	int miny, maxy;
	int sx, sy, tx, ty;
	int index[100];
	int *judge = NULL;
	int x;
	line_point point;
	int i, i1, l, j1;
	int width = w;

	miny = adas_draw_get_polygon_miny(points, size);
	maxy = adas_draw_get_polygon_maxy(points, size);

	judge = (int *)rt_malloc(sizeof(int) * size);
	if (judge == NULL)
		return;

	rt_memset(index, -1, sizeof(int) * 100);
	rt_memset(judge, 0, sizeof(int) * size);

	/* keep the border color, min value plus border
	 * width, max value minus border width
	 */
	for (i = miny + 2; i <= maxy - 2; i++) {
		/* Record the intersection of the scan line and the sideline */
		int temp = 0;
		for (i1 = 0, l = size, j1 = l - 1; i1 < l; j1 = i1, i1++) {
			sx = points[i1].x;
			sy = points[i1].y;
			tx = points[j1].x;
			ty = points[j1].y;
			int lowy, heighty;
			lowy = (sy < ty) ? sy : ty;
			heighty = (sy > ty) ? sy : ty;
			/* horizontal line */
			if (ty == sy) {
				if (i == ty) {
					int xmax, xmin, xx;
					xmax = (sx > tx) ? sx : tx;
					xmin = (sx < tx) ? sx : tx;
					/* keep the border color, min value plus border
					 * width, max value minus border width
					 */
					for (xx = xmin + 2; xx <= xmax - 2; xx++) {
						point.x = xx;
						point.y = i;

						adas_draw_set_px(buff, point.x,
								point.y, width, color);
					}
				}
				continue;
			}
			/* no intersection */
			if (i < lowy || i > heighty)
				continue;
			x = sx + (i - sy) * (tx - sx) / (ty - sy);
			/* Determine if the intersection is a vertex */
			if ((x == points[i1].x && i == points[i1].y)) {
				/* To determine whether a vertex is an extremum */
				/* It is mean to determine whether the other two points of
				 * the two lines associated with the intersection are on
				 * the same side of the intersection */
				if (i1 != (l - 1) && judge[i1] == 0) {
					if ((i - points[i1 + 1].y) *
						(i - points[j1].y) < 0) {
						/* different number */
						index[temp++] = x;
					} else {
						/* The extreme value of the same sign
						 * was recorded twice */
						index[temp++] = x;
						index[temp++] = x;
					}
				} else if (i1 == (l-1) && judge[i1] == 0) {
					if ((i - points[0].y) *
						(i - points[j1].y) < 0) {
						/* different number */
						index[temp++] = x;
					} else {
						/* The extreme value of the same sign
						 * was recorded twice */
						index[temp++] = x;
						index[temp++] = x;
					}
				}
				judge[i1] = 1;
				continue;
			} else if ((x == points[j1].x &&
				i == points[j1].y)) {
				if (j1 != 0 && judge[j1] == 0) {
					if ((i - points[i1].y) *
						(i - points[j1-1].y) < 0) {
						/* different number */
						index[temp++] = x;
					} else {
						/* The extreme value of the same sign
						 * was recorded twice */
						index[temp++] = x;
						index[temp++] = x;
					}
				} else if (j1 == 0 && judge[j1] == 0) {
					if ((i - points[i1].y) *
						(i - points[l-1].y) < 0) {
						/* different number */
						index[temp++] = x;
					} else {
						/* The extreme value of the same sign
						 * was recorded twice */
						index[temp++] = x;
						index[temp++] = x;
					}
				}
				judge[j1] = 1;
				continue;
			}
			/* The intersection is not vertex */
			index[temp++] = x;
		}
		/* Fill polygon */
		adas_draw_msort(index, 0, temp);

		int n, m, xx;
		for (n = 0, m = n + 1; m < temp && index[n] != -1; n += 2, m = n + 1) {
			/* keep the border color, min value plus border
			 * width, max value minus border width
			 */
			for (xx = index[n] + 2; xx <= index[m] - 2; xx++) {
				point.x = xx;
				point.y = i;

				adas_draw_set_px(buff, point.x, point.y, width, color);
			}
		}
		int k;
		for (k = 0; k < 100; k++)
			index[k] = -1;
	}

	if (judge) {
		rt_free(judge);
		judge = NULL;
	}
}

void car_recorder_draw_line(uint8_t *buff, line_point point1,
			line_point point2 , uint32_t color)
{
	int x0, y0, x1, y1;
	uint32_t px;

	x0 = point1.x;
	y0 = point1.y;
	x1 = point2.x;
	y1 = point2.y;

	APP_LOG_D("x0 = %d, y0 = %d, x1 = %d, y1 = %d\n", x0, y0, x1, y1);

	int dx = abs(x1-x0), sx = x0 < x1 ? 1 : -1;
	int dy = abs(y1-y0), sy = y0 < y1 ? 1 : -1;
	int err = (dx > dy ? dx : -dy)/2, e2;

	for (;;) {
		px = BSD_BKL_LINE_WIDTH_MAX * y0 * sizeof(uint32_t)
			+ x0 * sizeof(uint32_t);
		if (px < BSD_BKL_LINE_WIDTH_MAX * BSD_BKL_LINE_HEIGHT_MAX * 4 - 4)
			memcpy(&buff[px], &color, sizeof(uint32_t));

		if (x0 == x1 && y0 == y1)
			break;
		e2 = err;
		if (e2 > -dx) {
			err -= dy;
			x0 += sx;
		}
		if (e2 < dy) {
			err += dx;
			y0 += sy;
		}
	}
}

int car_recorder_draw_polygon(unsigned char *buff,
			line_point *points, uint32_t color)
{
	line_point polygon_points[4];
	int width;

	if (points == NULL)
		return -1;

	polygon_points[0].x = points[0].x;
	polygon_points[0].y = points[0].y;
	polygon_points[1].x = points[1].x;
	polygon_points[1].y = points[1].y;
	polygon_points[2].x = points[2].x;
	polygon_points[2].y = points[2].y;
	polygon_points[3].x = points[3].x;
	polygon_points[3].y = points[3].y;

	width = points[2].x - points[1].x;
	g_act_width = get_polygon_maxx(points, 4) -
			get_polygon_minx(points, 4);

	adas_draw_polygon(buff, polygon_points, 4, width, color);
	adas_draw_scanfill_polygon(buff, polygon_points, 4, width, color);

	return 0;
}

